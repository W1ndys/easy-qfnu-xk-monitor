# 选课监控系统开发方案

## 一、项目概述

### 1.1 功能目标

在现有 CAS 登录骨架基础上，开发一个选课监控系统。程序每 2 秒轮询教务系统选课查询接口，自动对比前后两次查询结果差异，将新出现的课程数据通过 OneBot HTTP 协议推送到指定 QQ 群聊。

### 1.2 核心流程

```
启动 → 读取环境变量 → CAS 登录教务系统 → 获取选课轮次 → 进入选课页面
  → 进入轮询循环：
      → 遍历预设课程列表
      → 对五个选课模块分别搜索
      → 合并结果并去重
      → 与上一轮结果对比
      → 发现新增数据 → 推送到 OneBot 群聊
      → 等待 2 秒 → 继续下一轮
```

### 1.3 环境变量清单

| 变量名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| `QFNU_USERNAME` | string | 是 | 登录学号 | `2023000001` |
| `QFNU_PASSWORD` | string | 是 | 登录密码 | `password123` |
| `ONEBOT_URL` | string | 是 | OneBot HTTP 接口地址 | `http://127.0.0.1:3000` |
| `ONEBOT_TOKEN` | string | 否 | OneBot 访问密钥（Bearer Token） | `your_token_here` |
| `GROUP_LIST` | string | 是 | 推送群号列表，逗号分隔 | `123456,789012,345678` |
| `COURSE_LIST` | string | 是 | 监控课程号列表，逗号分隔 | `A001,B002,C003` |
| `POLL_INTERVAL` | string | 否 | 轮询间隔秒数，默认 2 | `2` |

---

## 二、项目结构设计

### 2.1 目录结构

```
easy-qfnu-xk-monitor/
├── main.go                     # 程序入口，启动主流程
├── go.mod
├── go.sum
├── .env.example                # 环境变量模板（需更新）
├── pkg/
│   ├── auth/
│   │   └── crypto.go           # [已有] AES 加密
│   ├── cas/
│   │   ├── client.go           # [已有] HTTP 客户端
│   │   └── login.go            # [已有] CAS 登录流程
│   ├── jwxt/                   # [新建] 教务系统交互层
│   │   ├── round.go            # 获取并解析选课轮次
│   │   └── search.go           # 五模块课程搜索
│   ├── monitor/                # [新建] 监控核心逻辑
│   │   └── monitor.go          # 轮询、对比、调度
│   ├── notify/                 # [新建] 消息推送层
│   │   └── onebot.go           # OneBot HTTP 推送
│   └── config/                 # [新建] 配置管理
│       └── config.go           # 环境变量加载与校验
├── docs/
│   ├── qfnu-cas-login-api.md   # [已有] CAS 登录文档
│   ├── 选课API.md               # [已有] 选课接口文档
│   ├── 获取选课轮次.md          # [已有] 轮次接口文档
│   └── 选课监控开发方案.md      # [本文档]
├── data/                       # [运行时生成] 持久化数据（已 gitignore）
│   └── last_result.json        # 上一轮查询结果快照
└── deploy.ps1                  # [已有] 部署脚本
```

### 2.2 模块职责划分

| 模块 | 包路径 | 职责 |
|------|--------|------|
| 配置管理 | `pkg/config` | 加载 `.env` 和环境变量，校验必填项，解析列表类参数 |
| CAS 登录 | `pkg/cas` | 已有，提供登录后的 `*http.Client` |
| 教务交互 | `pkg/jwxt` | 获取选课轮次、进入选课页面、五模块课程搜索 |
| 监控核心 | `pkg/monitor` | 定时轮询、结果对比、新增检测、调度推送 |
| 消息推送 | `pkg/notify` | OneBot HTTP 协议群消息发送 |

---

## 三、开发阶段规划

### 阶段一：地基层 —— 配置管理与数据结构定义

**目标**：建立项目的配置基础和核心数据结构，为后续所有模块提供统一的类型定义。

#### 任务 1.1：更新环境变量模板

修改 `.env.example`，新增 OneBot、群列表、课程列表等配置项。

#### 任务 1.2：实现配置加载模块 `pkg/config/config.go`

定义 `Config` 结构体，包含所有环境变量字段：

```go
type Config struct {
    Username     string   // QFNU_USERNAME
    Password     string   // QFNU_PASSWORD
    OneBotURL    string   // ONEBOT_URL
    OneBotToken  string   // ONEBOT_TOKEN（可选）
    GroupList    []string // GROUP_LIST 解析后
    CourseList   []string // COURSE_LIST 解析后
    PollInterval int      // POLL_INTERVAL，默认 2
}
```

实现逻辑：
- 调用 `godotenv.Load()` 加载 `.env` 文件
- 从 `os.Getenv` 读取各变量
- 对 `GROUP_LIST` 和 `COURSE_LIST` 按逗号分割成 `[]string`
- 校验必填项，缺失则返回明确错误信息
- `POLL_INTERVAL` 缺失或非法时默认为 2

#### 任务 1.3：定义核心数据结构

在 `pkg/jwxt/search.go` 中定义课程搜索结果的结构体，对应选课 API 返回的 JSON：

```go
// CourseInfo 对应选课搜索接口返回的单条课程数据
type CourseInfo struct {
    Kch        string `json:"kch"`        // 课程号
    Kcmc       string `json:"kcmc"`       // 课程名称
    Skls       string `json:"skls"`       // 授课教师
    Syrs       string `json:"syrs"`       // 剩余人数
    Jx0404id   string `json:"jx0404id"`   // 教学班ID
    Jx02id     string `json:"jx02id"`     // 课程ID
    Sksj       string `json:"sksj"`       // 上课时间
    Xkrs       int    `json:"xkrs"`       // 已选人数
    Pkrs       int    `json:"pkrs"`       // 排课人数
    Dwmc       string `json:"dwmc"`       // 开课单位
    Ktmc       string `json:"ktmc"`       // 课堂名称
    Skdd       string `json:"skdd"`       // 上课地点
}

// SearchResponse 对应搜索接口的完整返回
type SearchResponse struct {
    AaData []CourseInfo `json:"aaData"`
}
```

定义用于去重和对比的唯一键生成规则：以 `jx0404id`（教学班ID）+ `jx02id`（课程ID）组合作为唯一标识，格式为 `"{jx02id}_{jx0404id}"`。

---

### 阶段二：核心交互层 —— 教务系统接口对接

**目标**：实现与教务系统的两个关键交互——获取选课轮次和课程搜索。

#### 任务 2.1：实现选课轮次获取 `pkg/jwxt/round.go`

实现逻辑：

1. **GET 请求** `http://zhjw.qfnu.edu.cn/jsxsd/xsxk/xklc_list`，携带登录后的 Cookie
2. **HTML 解析**（使用 goquery）：
   - 优先查找 `#jrxk` 元素的 `href` 属性，提取 `jx0502zbid` 参数
   - 若 `href` 为空或为 `javascript:`，从 `onclick` 属性提取，格式为 `jrxk('jx0502zbid值')`
   - 备选：查找所有含 `onclick*='xsxkFun'` 的 `<a>` 标签，从 `href` 中解析
3. **返回**轮次 ID（`jx0502zbid`）

函数签名：

```go
func GetSelectionRoundID(ctx context.Context, client *http.Client) (string, error)
```

#### 任务 2.2：实现进入选课页面

获取轮次 ID 后，需 GET 访问选课入口页面让 Cookie 生效：

```
GET http://zhjw.qfnu.edu.cn/jsxsd/xsxk/xsxk_index?jx0502zbid={id}
```

此步骤不需要解析返回内容，仅需确保请求成功（HTTP 200），使服务端在当前会话中激活选课功能。

#### 任务 2.3：实现五模块课程搜索 `pkg/jwxt/search.go`

五个选课搜索模块的定义：

| 模块标识 | 中文名称 | 搜索路径 |
|---------|---------|---------|
| `xsxkKnjxk` | 专业内跨年级选课 | `/jsxsd/xsxkkc/xsxkKnjxk` |
| `xsxkBxqjhxk` | 本学期计划选课 | `/jsxsd/xsxkkc/xsxkBxqjhxk` |
| `xsxkXxxk` | 选修选课 | `/jsxsd/xsxkkc/xsxkXxxk` |
| `xsxkFawxk` | 计划外选课 | `/jsxsd/xsxkkc/xsxkFawxk` |
| `xsxkGgxxkxk` | 公选课选课 | `/jsxsd/xsxkkc/xsxkGgxxkxk` |

**搜索单个模块**的实现逻辑：

1. 构造 POST 请求到 `http://zhjw.qfnu.edu.cn/jsxsd/xsxkkc/{moduleType}`
2. Query 参数：
   - `kcxx` = 课程号（搜索关键词）
   - `skls` = ""（不限教师）
   - `sfym` = "true"（过滤已满）
   - `sfct` = "false"（不过滤冲突）
   - `sfxx` = "false"（不过滤限选）
3. Body（form-urlencoded）：
   - `iDisplayStart` = "0"
   - `iDisplayLength` = "10000"
4. 解析 JSON 响应为 `SearchResponse`
5. 返回 `[]CourseInfo`

函数签名：

```go
func SearchModule(ctx context.Context, client *http.Client, moduleType string, courseKeyword string) ([]CourseInfo, error)
```

**搜索全部五个模块**的实现逻辑：

对每个课程关键词，遍历五个模块分别调用 `SearchModule`，然后合并结果并按 `jx02id_jx0404id` 组合键去重。

函数签名：

```go
func SearchAllModules(ctx context.Context, client *http.Client, courseKeyword string) ([]CourseInfo, error)
```

---

### 阶段三：推送层 —— OneBot 消息通知

**目标**：实现 OneBot HTTP 协议的群消息推送功能。

#### 任务 3.1：实现 OneBot 推送 `pkg/notify/onebot.go`

**OneBot HTTP 发送群消息接口**：

```
POST {ONEBOT_URL}/send_group_msg
```

请求头：
- `Content-Type: application/json`
- `Authorization: Bearer {ONEBOT_TOKEN}`（如果配置了 Token）

请求体：

```json
{
    "group_id": 123456,
    "message": "消息内容"
}
```

实现逻辑：

1. 定义 `Notifier` 结构体，持有 `OneBotURL`、`OneBotToken`、`GroupList`、`*http.Client`
2. 实现 `SendGroupMessage(groupID string, message string) error`，发送单条群消息
3. 实现 `BroadcastMessage(message string) error`，遍历群列表逐个发送
4. 请求失败时记录日志但不中断程序（推送失败不应影响监控主循环）

#### 任务 3.2：定义消息格式化函数

将 `CourseInfo` 格式化为可读的推送文本：

```
【选课监控】发现新课程！
━━━━━━━━━━━━━━━━
课程名称：高等数学
课程号：A001
授课教师：张三
上课时间：周一1-2节
上课地点：教学楼A101
剩余人数：5
已选/排课：35/40
开课单位：数学学院
━━━━━━━━━━━━━━━━
```

如果一次检测到多条新增，合并为一条消息推送，避免消息轰炸。

---

### 阶段四：核心调度层 —— 监控轮询引擎

**目标**：实现定时轮询、数据对比和新增检测的核心逻辑。

#### 任务 4.1：实现监控器 `pkg/monitor/monitor.go`

定义 `Monitor` 结构体：

```go
type Monitor struct {
    client     *http.Client       // 登录后的 HTTP 客户端
    config     *config.Config     // 配置
    notifier   *notify.Notifier   // 推送器
    lastResult map[string]jwxt.CourseInfo // 上一轮结果快照，key 为 jx02id_jx0404id
}
```

#### 任务 4.2：实现单轮查询逻辑

单轮查询流程：

1. 遍历 `config.CourseList` 中的每个课程号
2. 对每个课程号调用 `jwxt.SearchAllModules`（内部遍历五个模块）
3. 将所有结果合并到一个 `map[string]CourseInfo`（以 `jx02id_jx0404id` 组合为 key 去重）
4. 与 `lastResult` 对比，找出新增的条目（在当前结果中存在但在上轮结果中不存在的组合键）
5. 如果有新增条目，调用 `notifier.BroadcastMessage` 推送
6. 用当前结果覆盖 `lastResult`

#### 任务 4.3：实现轮询循环

使用 `time.Ticker` 实现定时轮询：

1. 创建 `time.NewTicker(time.Duration(config.PollInterval) * time.Second)`
2. 在 `for range ticker.C` 循环中执行单轮查询
3. 首次执行时，仅记录结果不推送（作为基准快照）
4. 支持 `context.Context` 取消，以便优雅退出

#### 任务 4.4：错误处理策略

- **搜索请求失败**：记录日志，跳过本轮，不更新 `lastResult`，继续下一轮
- **会话过期**（返回登录页或非预期响应）：尝试重新登录，登录失败则记录错误并继续重试
- **推送失败**：记录日志，不影响监控主循环
- **所有错误均不应导致程序退出**，保持持续运行

#### 任务 4.5：状态持久化

实现 `lastResult` 的文件读写：

1. 定义 `saveSnapshot(data map[string]CourseInfo) error`，将 map 序列化为 JSON 写入 `data/last_result.json`（先写临时文件再重命名）
2. 定义 `loadSnapshot() (map[string]CourseInfo, error)`，启动时从文件恢复上次状态
3. 每轮更新 `lastResult` 后调用 `saveSnapshot`
4. 启动时调用 `loadSnapshot`，加载成功则首轮即可对比推送；加载失败则首轮仅记录不推送

---

### 阶段五：主入口改造与整合

**目标**：改造 `main.go`，串联所有模块，实现完整的启动流程。

#### 任务 5.1：改造 `main.go`

新的 `main.go` 执行流程：

1. **加载配置**：调用 `config.Load()` 获取所有环境变量
2. **CAS 登录**：使用现有 `cas` 包进行登录，获取带 Cookie 的 `*http.Client`
3. **获取选课轮次**：调用 `jwxt.GetSelectionRoundID` 获取当前可用轮次
4. **进入选课页面**：GET 访问选课入口 URL 使 Cookie 生效
5. **初始化推送器**：创建 `notify.Notifier`
6. **启动监控器**：创建 `monitor.Monitor` 并启动轮询循环
7. **信号处理**：监听 `SIGINT`/`SIGTERM`，优雅退出

#### 任务 5.2：更新 `.env.example`

新增所有新环境变量的模板和注释说明。

#### 任务 5.3：日志规范

- 使用标准库 `log` 包
- 格式：`[时间] [级别] 消息内容`
- 关键日志点：
  - 启动时打印配置摘要（隐藏密码）
  - 登录成功/失败
  - 进入选课轮次成功
  - 每轮查询的课程数量统计
  - 发现新增课程时的详情
  - 推送成功/失败
  - 错误和重试信息

---

## 四、数据对比与去重算法

### 4.1 去重规则

以 `jx02id`（课程ID）+ `jx0404id`（教学班ID）的组合作为唯一标识，格式为 `"{jx02id}_{jx0404id}"`。单独使用 `jx0404id` 不够可靠，需要结合 `jx02id` 才能精确区分不同课程的不同教学班。同一课程可能在不同模块中出现（比如一门课既出现在"本学期计划选课"也出现在"选修选课"），使用 `map[string]CourseInfo` 以组合键为 key 自然去重。

### 4.2 对比算法

```
// 唯一键 = jx02id + "_" + jx0404id
currentResult = 本轮搜索结果 map[uniqueKey]CourseInfo
lastResult    = 上轮搜索结果 map[uniqueKey]CourseInfo

newItems = []CourseInfo{}
for key, course := range currentResult {
    if _, exists := lastResult[key]; !exists {
        newItems = append(newItems, course)
    }
}

if len(newItems) > 0 {
    推送 newItems
}

lastResult = currentResult  // 整体替换
```

### 4.3 首次运行

首次运行时 `lastResult` 为空，所有搜索到的结果都会被视为"新增"。为避免首次启动时大量推送，**首轮仅记录不推送**，从第二轮开始才进行对比和推送。

### 4.4 状态持久化（重启恢复）

`lastResult` 默认仅存在于内存中，程序重启后会丢失。为避免重启后将所有已有课程当作"新增"重复推送，需要将状态持久化到本地文件。

**实现方式**：使用 JSON 文件存储快照，路径为项目根目录下的 `data/last_result.json`。

**写入时机**：每轮查询完成、更新 `lastResult` 后，将当前 map 序列化为 JSON 写入文件。

**读取时机**：程序启动时，如果 `data/last_result.json` 存在且内容合法，则加载为 `lastResult` 初始值。此时首轮即可进行对比和推送，无需跳过。如果文件不存在或解析失败，则回退到"首轮仅记录不推送"的逻辑。

**文件格式**：

```json
{
  "jx02id1_jx0404id1": { "kch": "A001", "kcmc": "高等数学", ... },
  "jx02id2_jx0404id2": { "kch": "B002", "kcmc": "线性代数", ... }
}
```

**注意事项**：
- 写文件时先写临时文件再原子重命名，避免写入中途崩溃导致文件损坏
- `data/` 目录不存在时自动创建
- `.gitignore` 中应忽略 `data/` 目录

---

## 五、会话保活与异常恢复

### 5.1 会话过期检测

教务系统会话有时效性。检测方式：

- 搜索接口返回非 JSON 内容（可能是登录页 HTML）
- HTTP 状态码为 302（重定向到登录页）
- JSON 解析失败

### 5.2 自动重新登录

检测到会话过期时：

1. 记录日志"会话过期，正在重新登录"
2. 重新执行完整的 CAS 登录流程
3. 重新获取选课轮次并进入选课页面
4. 登录成功后继续监控循环
5. 连续登录失败时，采用退避重试（间隔递增）

---

## 六、开发优先级与依赖关系

```
阶段一（配置与数据结构）
   ↓
阶段二（教务系统接口对接）← 依赖阶段一的数据结构
   ↓
阶段三（OneBot 推送）← 依赖阶段一的配置
   ↓
阶段四（监控引擎）← 依赖阶段二和阶段三
   ↓
阶段五（主入口整合）← 依赖全部阶段
```

每个阶段完成后应可独立编译通过，便于逐步验证。

---

## 七、外部依赖

### 7.1 已有依赖

| 依赖 | 用途 |
|------|------|
| `github.com/PuerkitoBio/goquery` | HTML 解析（提取轮次信息） |
| `github.com/joho/godotenv` | `.env` 文件加载 |

### 7.2 无需新增依赖

本方案不需要引入新的第三方库。所有新功能均可通过 Go 标准库实现：

- HTTP 请求：`net/http`
- JSON 解析：`encoding/json`
- URL 构造：`net/url`
- 定时器：`time.Ticker`
- 信号处理：`os/signal`
- 字符串处理：`strings`、`strconv`

---

## 八、关键注意事项

### 8.1 请求频率

- 轮询间隔默认 2 秒，可通过 `POLL_INTERVAL` 调整
- 每轮需要对每个课程关键词搜索 5 个模块，如果配置了 N 个课程号，每轮将产生 5*N 次 HTTP 请求
- 应在每次请求之间适当添加短暂延迟（如 100ms），避免被教务系统识别为异常流量

### 8.2 教务系统特性

- 所有请求使用 HTTP（非 HTTPS）
- 教务系统基址：`http://zhjw.qfnu.edu.cn`
- 搜索接口返回 JSON，轮次页面返回 HTML
- Cookie（JSESSIONID）是维持会话的核心

### 8.3 OneBot 协议

- 使用 HTTP POST 发送群消息
- 端点路径：`/send_group_msg`
- `group_id` 应为整数类型（从字符串环境变量解析为 int64）
- Token 通过 `Authorization: Bearer {token}` 请求头传递
